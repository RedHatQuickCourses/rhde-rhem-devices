:time_estimate: 9

= Red Hat Edge Manager Services and Installation

_Estimated reading time: *{time_estimate} minutes*._

Objective::

Describe the main services that comprise Red Hat Edge Manager and how to deploy them as quadlets in RHEL servers, without dependencies on external services such as ACM, AAP, or Keycloack.

WARNING: Work in progress

////

* Architectural components (slide #13) and services of RHEM: microservices/API, inventory, web UI (on server) and agent (on managed devices) https://docs.google.com/presentation/d/17cWSUdQnS5mSHaiLQieJO24tiPp3VzAu9dIsKc-fyAw/edit?slide=id.g33d0db3e9fb_0_2408#slide=id.g33d0db3e9fb_0_2408

* Mention supported configuration and authentication providers, and their purpose, how they enable seamless integration with ACM or AAP, but focus on the ones to be used in the course: inline, Git, and sssd.

* Overview of the process of deploying containerized RHEM (quadlets) from RPM Packages.

* If there are issues configuring the sssd authentitcaion provider, or if it does not support RBAC, it may become necessary to include Keycloack.

////

As we already say in the previous chapter, Red Hat Edge Manager (RHEM) is based on the Flight Control open source project and is composed of two main pieces: an RHEM server, which runs a collection of microservices, fronted by an API server, and a RHEM agent, which runs on individual managed devices.

image::ch1-intro:agent-vs-server.svg[tilte="RHEM agent (on managed devices) and RHEM server"]

You manage edge devices by making changes to the state of devices and fleets, using the RHEM API.
The RHEM agent observes the state stored on the server and the state of the device itself, reconcilling any differences.

There are many ways of deploying the RHEM microservices, and this course focuses on installing RHEM standalone on RHEL servers.
RHEM microservices run as Podman containers, managed by the System Daemon (Systemd) using quadlets.

Before describing how to install RHEM services and quadlets on a RHEL server, let's take a closer look at the RHEM architecture and its microservices.

== API, command-line, and web interfaces

Though you could interact directly with the RHEM API, and there is even an https://galaxy.ansible.com/ui/repo/published/flightctl/core/docs/[Ansible content collection^] that does it, you would usually interact with RHEM by using either its command-line interface (CLI), provided by the `flightctl` command, or its web user interface (UI).

image::RHEM-arch.svg[title="High-level architecture of RHEM"]

The CLI has native ports for all major operating system, and the web UI usually runs in the same machine as the RHEM microservices, though it does not need to.
The majority of tasks can be performed using either the CLI or the web UI.
As expected, the web UI offers ease of use, while the CLI offers scriptability.

The RHEM microservices use a PostgreSQL relational database for persisting device state and its API resources, and can be configured with a number of different authentication, authorization, certificate, and configuration providers. 

Configuration of the RHEM microservices is not usually done using its API, but by editting configuration files (if RHEM is deployed in RHEL) or Kubernetes resources (if RHEM is deployed on OpenShift).

NOTE: This course does not teach how to configure different providers and other aspects of RHEM microservices.
It sticks to the installation defaults, which use Linux PAM for authentication and authorization, and a self-signed certificate.
This course focuses on using the RHEM API to manage devices.

Depending on the authentication provider, it may not be possible to authenticate to RHEM using the CLI. In that case, the CLI can invoke a web browser to perform authentication and them use the returned token.

RHEM agents also invoke the RHEM API, but using a different entrypoint than the CLI and web UI do, and authenticate using a certificate generated during device enrollment time.

== RHEM microservices

RHEM runs a number of microservices, each on its own container, including a few optional observability microservices.

image::RHEM-components.svg[title="RHEM microservices"]

If you deploy RHEM standalone on RHEL, each microservice becomes a System Daemon (Systemd) service unit, as well as their supporting services.
The PostgreSQL database corresponds to the `flightctl-db` service and container, and the Redis cache corresponds to the `flightctl-kv` service and container.

There may be a few service units and containers not included in the previous diagram, for example a service that provides downloads of the RHEM CLI. Tasks such as initializing the RHEM database, or migrating its schema during RHEM version updates, or generating TLS certificates for acessing RHEM API access, are also performed by containers running from one-shot Systemd units.

== PAM authentication with RHEM

In the simplest deployment of standalone RHEM on RHEM, a special microservice called `flightctl-pam-issuer` runs an OpenID Connect (ODIC) provider based on Linux PAM.

Using its default configuation, the PAM issuer service uses UNIX passwd, shadow, and group files to manage authentication and authorization for the RHEM API.

The PAM issuer does not use the user and group files from its host RHEL server, but contains its own copy of these files.
You must manage these files inside the container, using standard Linux tools such as the `useradd` command.
The default configuration makes the Linux users of the PAM issuer container independent of the Linux users of its host, so a RHEM user does not get console or SSH access to the RHEM server host.

Future releases of RHEM may expand the PAM issuer to support authentication and authorization using Red Hat Identity Manager (IdM), Microsoft Active Directory (MSAD), and other enterprise authentication systems based on the Kernberos and LDAP protocols by using the Secure System Services Daemon (sssd).

IMPORTANT: The recommended approach for a production-grade deployment of RHEM is configuring an ODIC provider which connects to an OAuth-based enterprise or cloud identity system, such as Red Hat build of Keycloack, Microsoft EntraID, Auth0 by Okta, or Google Cloud Authentication.

== Installing RHEM standalone on RHEL

Before you attempt to install RHEM on RHEL, you must log in to the Red Hat registry (`registry.redhat.io`) using a valid Red Hat customer portal account, as the root user.
This step is necessary because the RHEM packages only configure Systemd units and their respective Podman Quadlets.
These units pull RHEM container images, but will fail if there is no registry access token in the container environment of the root user.

To install RHEM on RHEL, you must have access to a Red Hat subscription with entitles RHEM and enable, using subcription manager, the package repository channel named `edge-manager-1.0-for-rhel-9-x86_64-rpms`.

Alternatively, you could enable the https://github.com/flightctl/flightctl-rpm[upstream RPM repository^] from the Flight Control project, which works for learning purposes, especially given that early releases are likely to be functionally equivalent to the RHEM product.
In that case, you do not need to log in to the Red Hat registry.

Then you install the `flightctl-services` package, which configures Systemd units for all necessary RHEM microservices.
The same package configures Systemd units to perform one-time initialization of the services which require it.
Finally, you enable and start the `flightctl` target on Systemd.

Additional `flightctl-*` packages provide optional microservices, such as the observability components, and the CLI, which you can install afterwards or before starting RHEM.

If your RHEM server has firewall services enabled, you should check the product or upstream documentation for the list of TCP ports to open.
You must expose not only the API and web UI ports, but also a few other services, for external network connections.

You should expect it, but, anyway, we say it out loud: do not disable SELinux.
RHEM includes a SELinux policy for the targeted mode, as you would expect from any production-grade software.

After RHEM services are up and running, you may configure users and groups on the `flightctl-pam-issuer` container, or configure an enterprise OIDC provider.

== Where is RHEM data stored?

After you start a RHEM server, you will not find a `/var/lib/pgsql/data/` directory for PostgreSQL data on your RHEM server host.
That directory exists only inside the `flightctl-db` container, and it is a Podman volume.

If you must perform database backups and other database management operations, you must perform them inside the database container.

Similarly, you will not find Redis data directories or API access and audit logs on your RHEM server host, and must manage their Podman volumes or enter the respective container namespaces.

Future releases of RHEM will support external databases, so you can provide a properly configured, high-available database server to store RHEM data and managed device state.

== What's Next

The next activity installs and configures a RHEM server, and the next chapter provisions and enrolls managed edge devices on RHEM.
