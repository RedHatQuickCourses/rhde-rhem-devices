:time_estimate: 5
:edge-1-uuid-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: 1u63hvsgtua9tjjbmla9bgh5h2s77cb8esepphnf68m3ocf8qfng
:edge-2-uuid-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: g7ombcqk46tqq458j9uju454441mf1lgt9qqqva8ti0fnvosm57g
:rhem-enroll-v1-shaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: 503f839113b376c55ceee225a8cbfdc9bf1496f3342385ce171f2cf2e01f1333

= Lab: Enroll Edge Devices Using Late Binding

_Estimated reading time: *{time_estimate} minutes*._

Objective::

Provision and enroll devices on RHEM from an installation ISO.

WARNING: Work in progress

== Before you begin

You need a customer portal account with access to a Red Hat Enterprise Linux (RHEL) subscription.
It could be a https://developers.redhat.com/products/rhel/download[Red Hat Developer program] free subscription.

You need a _development machine_ running RHEL, to which you have unrestricted sudo access.
//On the next activities, you will use the _development machine_ to run test VMs that stand in for edge devices to be managed by RHEM.

You also need a _server machine_ running RHEL, to which you also have unrestricted sudo access, which was already configured with RHEM by the xref:ch2-deploy:s2-install-lab.adoc[previous lab].

Finally, you need a _private registry_ to store bootc container images for your managed edge devices.

Your _development machine_ requires internet access to download RPM packages and container images.

If you are using the course classroom, your _development machine_ is the `workstation` VM.
Log in as the user `student` with password `student`.
From that machine, you may start SSH sessions to the `servera` VM, which is your _server_ machine, using the same user.
Alternatively, you can open a shell or a console directly on the `servera` VM.

== Instructions

////

* Build a generic RHEM enrollment image with bootc.

* Build an installable ISO with bootc image builder.

* Create a number of local VMs using virt-install and the same ISO, to show that each becomes a different device and each gets its own per-device certificate, after enrollment.

* Create/boot all VMs/devices at once (or all remaining devices, after the first one) to demonstrate the issue of identifying each individual device, so they can be assigned the right labels.

* Demonstrate both CLI and web-based workflows for approving device enrollment.

* To keep this lab short and simple, devices are left “naked”, undifferentiated in terms of configurations, application, sites, and fleets.

* Prefer late binding, as the recommended approach, unless there are issues with adding the RHEM agent data to the kickstart on the ISO.

* Do NOT include any initial user, to demonstrate that you can access devices though RHEM, without a SSH key or user/password.

[ Could have two generic enrollment images, one with early binding data, but this basically makes the lab twice as long relative to its wall time. Building images and ISOs are not quick operations. ]

[ This is looking like a long lab, maybe break the image/ISO building as a lab before the actual device enrollment and provisioning? ]

////

You will build a minimal bootc container image which contains the RHEM agent and create an installable ISO which contains enrollment credentials.
Then you will use that ISO to provision a test VM, which stands in for a managed edge device, and verify that it attempts to enroll in your RHEM server.
Finally, you will approve that device enrollment request, and verify that you can use the same ISO, unchanged, to provision additional edge devices.

1. On your _development machine_, create a bootc container image including the RHEM agent.

.. Clone the course samples repository
+
[source,subs="verbatim,quotes"]
--
$ *git clone https://github.com/RedHatQuickCourses/rhde-rhem-samples.git*
Cloning into 'rhde-rhem-samples'...
...
--

.. Copy the Containerfile and related files for the enrollment image to a work directory.
Then make the work directory your current directory.
+
[source,subs="verbatim,quotes"]
--
$ *cp -r rhde-rhem-samples/enroll temp-enroll*
$ *cd temp-enroll*
--

.. Review the Containerfile that builds a minimal enrollment image.
+
It adds two things over a base RHEL 9 bootc container image.
+
--
... Installs the RHEM agent package.

... Masks the bootc update time service, so RHEM has control system updates.
--
+
Because it doesn't include RHEM server data nor a client enrollment certiticate, that same bootc image could be used with different RHEM servers.
Your organization may opt to add more things to that image, for example anti-malware packages and enabling firewalld.
+
[source,subs="verbatim,quotes"]
--
$ *less Containerfile*
include::1@samples:enroll:example$Containerfile[]
--
+
NOTE: If you want to try with the current lastest release of the upstream project, edit your Containerfile to remove the version component `-1.0.0~rc` from the package `flightctl-agent`.

.. Register your _development machine_ with the Red Hat subscription manager and log in on the Red Hat registry.
+
NOTE: You need to register the `workstation` VM because it needs to fetch RHEL 9 packages from Red Hat.
The configured mirror package repositories contain only RHEL 10 packages.
By the way, it is fully supported building RHEL 9 containers from a RHEL 10 host.
+
[source,subs="verbatim,quotes"]
--
$ *sudo subscription-manager register*
...
The registered system name is: workstation
$ *podman login registry.redhat.io*
Login Succeeded!
--
+
// Do registration, pre-pull, and other steps in an extra lab in ch1?

.. Build the bootc container image.
Notice that the `podman build` command finnishes with period, for the current directory.
+
[source,subs="verbatim,quotes,attributes"]
--
$ *podman build -t rhem-enroll .*
STEP 1/2: FROM registry.redhat.io/rhel9/rhel-bootc:9.6
...
Successfully tagged localhost/rhem-enroll:latest
{rhem-enroll-v1-shaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
--

.. Publish the container image in the private registry.
+
[source,subs="verbatim,quotes"]
--
$ *podman login -u student -p redhat registry.lab.example.com:5000*
Login Succeeded!
$ *skopeo copy containers-storage:localhost/rhem-enroll:latest docker://registry.lab.example.com:5000/rhem-enroll:v1.0*
...
Writing manifest to image destination
{rhem-enroll-v1-shaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
--

2. Create an installable ISO containing the bootc container image from the previous step.

.. Pull your bootc container image to the container storage of the root user.
+
[source,subs="verbatim,quotes,attributes"]
--
$ *sudo podman login -u student -p redhat registry.lab.example.com:5000*
Login Succeeded!
$ *sudo podman pull registry.lab.example.com:5000/rhem-enroll:v1.0*
...
Writing manifest to image destination
{rhem-enroll-v1-shaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
--

.. Review the TOML file, which embeds a kickstart script for unattended installation of RHEL.
+
That kickstart script contains a `%post` block that initializes credentials for console and SSH login with the `core` user and for enrollment in a RHEM server.
+
[source,subs="verbatim,quotes"]
--
$ *less Containerfile*
include::1@samples:enroll:example$config.toml[]
--

.. Set the initial user password in your kickstart script.
+
[source,subs="verbatim,quotes"]
--
$ *sed -i 's/REPLACE_WITH_PASSWD/redhat123/' config.toml*
--

.. Generate an SSH key and embed it in your kickstart script.
+
[source,subs="verbatim,quotes"]
--
$ *ssh-keygen -N '' -f edge-key -C 'initial key for edge devices'*
Generating public/private rsa key pair.
...
$ *SSH_PUB_KEY=$( cat edge-key.pub )*
$ *sed -i "s|REPLACE_WITH_SSH_KEY|$SSH_PUB_KEY|" config.toml*
--

.. Retrieve the enrollment configuration and certificate from RHEM and embed it in your kickstart script.
+
It may be necessary to login again to RHEM, depending on how much time is elabled since you completed the previous lab.
+
[source,subs="verbatim,quotes"]
--
$ *flightctl login -u admin -p redhat https://servera.lab.example.com:3443*
Login successful.
$ *flightctl certificate request --expiration=365d --output=embedded > config.yaml*
Creating new ECDSA key pair and writing to "client-enrollment.key".
Submitting certificate signing request "client-enrollment-ddbfd221"... success.
Waiting for certificate to be approved and issued.... success.
$ *sed -i -e '/REPLACE_WITH_CONFIG_YAML/r config.yaml' -e '/REPLACE_WITH_CONFIG_YAML/d' config.toml*
--

.. Review your `config.toml` file to be sure that all `REPLACE_WITH...` makers are gone.
+
NOTE: You can remove the files named `ca.crt`, `client-enrollment.crt`, and `client-enrollment.key`, created by the `flightctl certificate request` command, because their contents are embedded in the `client.yaml` file.

.. Create a temporary directory and use the provided script to invoke bootc image builder to produce an installable ISO image.
+
[source,subs="verbatim,quotes"]
--
$ *mkdir output*
$ *bash bib-iso.sh*
...
Build complete!
Results saved in .
--

3. Create a test VM using the installable ISO.

.. Copy the generated ISO image file to a more recognizable name, outside the temporary directory.
+
[source,subs="verbatim,quotes"]
--
$ *cp output/bootiso/install.iso rhem-enroll.iso*
--

.. Use the provided script to invoke `virt-install` to create a local test VM, booting it from the ISO.
+
The script expects a single digit as an argument, which is used to compose both the name of the VM and port-forwarding.
+
At the end of the instalation, press kbd:[Ctrl+]] to return to your shell.
+
[source,subs="verbatim,quotes"]
--
$ *bash virt-install 1*
Creating VM edge-1, use port 8122 for SSH.
GRAB OUTPUT
--

.. Access your test VM and verify it is running a RHEM agent.
+
[source,subs="verbatim,quotes"]
--
$ *ssh -i edge-key -p 8122 core@127.0.0.1*
...
core@enroll$
--

.. On your test VM, check the status of the `flightctl-agent` service and return to your host shell.
+
[source,subs="verbatim,quotes"]
--
$ *sudo bootc status*
GRAB OUTPUT
$ *sudo systemctl is-active flightctl-agent*
active
$ *sudo journalctl -u flightctl-agent*
GRAB OUTPUT
$ *exit*
--

4. On your _development machine_, approve the enrollment request

.. Verify that there is an enrollment request with an UUID which corresponds to the one in the logs of your test VM.
+
[source,subs="verbatim,quotes"]
--
$ *flightctl get device*
GRAB OUTPUT
$ *flightctl get enrollmentrequest*
GRAB OUTPUT
--

.. Approve the enrollment request, setting a couple labels to the managed device, especially the `alias` label which the web UI uses as the display name of managed devices.
+
[source,subs="verbatim,quotes,attributes"]
--
$ *flightctl approve enrollmentrequest {edge-1-uuid-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} -l alias=edge-1 -l rhel=9.6 -l type=none*
GRAB OUTPUT
--

.. Verify that the enrollment request now is set to approved and there is a managed device.
+
[source,subs="verbatim,quotes"]
--
$ *flightctl get device*
GRAB OUTPUT
$ *flightctl get enrollmentrequest*
GRAB OUTPUT
--

.. Wait a few moments while the RHEM agent finishes synchronizing the device with the configurations set by RHEM.
+
[source,subs="verbatim,quotes"]
--
$ *flightctl get device*
GRAB OUTPUT
--

5. Verify that the test VM is now managed by RHEM.

.. Because the device was just enrolled and it is not a member of a fleet, its configuration is empty.
+
[source,subs="verbatim,quotes"]
--
$ *flightctl get device {edge-1-uuid-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} -o yaml*
GRAB OUTPUT
--

.. You can use the device alias, instead of its UUID, with the following trick:
+
[source,subs="verbatim,quotes"]
--
$ *flightctl get device $( flightctl get device -o name -l alias=edge-1 )*
GRAB OUTPUT
--

.. Use the RHEM CLI to get a shell on the managed device.
+
[source,subs="verbatim,quotes"]
--
$ *flightctl console device/$( flightctl get device -o name -l alias=edge-1 )*
GRAB OUTPUT
--

.. On the managed device, verify that the logs RHEM agent record that the device was enrolled and synchronized.
+
[source,subs="verbatim,quotes"]
--
$ *sudo journalctl -u flightctl-agent*
GRAB OUTPUT
--
+
// FIND A WAY OF FILTERING THE LOGS FOR THE EVENTS WE WANT.

.. Create a file on the managed device, just so you can easily distinguish it from other managed devices.
+
[source,subs="verbatim,quotes"]
--
$ *echo 'managed #1' > device.txt*
--

.. Can I show the per-device certificate?

6. Provision another test VM using the same installable ISO.

.. Use the provided script to create a second test VM.
Reember to give it a different digit from the previous one.
+
At the end of the instalation, press kbd:[Ctrl+]] to return to your shell.
+
[source,subs="verbatim,quotes"]
--
$ *bash virt-install 2*
Creating VM edge-2, use port 8222 for SSH.
GRAB OUTPUT
--

.. Access your second test VM and verify it is running a RHEM agent.
Notice it has the same hostname as the first test VM, because that configuration is hardcoded in the kickstart script from the installation ISO.
+
[source,subs="verbatim,quotes"]
--
$ *ssh -i edge-key -p 8222 core@127.0.0.1*
...
core@enroll$
--

.. On your test VM, verify that it generates a different UUID to identify itself to RHEM.
+
[source,subs="verbatim,quotes"]
--
$ *sudo journalctl -u flightctl-agent*
GRAB OUTPUT
$ *exit*
--

7. Enroll your second test VM on RHEM, but this time using its web interface and a non-administrator user.

.. Open a web browser and visit `https://servera.lab.example.com`.

.. Log in as the `student` user with the `student` password.

.. The overview page should indicate that you have one healthy managed device.

.. On the left panel, click *Devices*.
The beginning of the page indicates that there's a device waiting to be enrolled.

.. Approve the device [ADD GUI INSTRUCTIONS, including setting alias and labels]

.. The devices page now shows no enrollment requests and shows the new managed device, still synchronized.

.. Wait a few moments until the device synchronizes with RHEM.

8. Verify that, despite being provisioned from the same enrollment request data, each VM retains its own identity and configuration from RHEM.

.. Enter device details

.. Open a device console

.. Show that there is no `device.txt` file.

.. Can I show the per-device certificate?


== What's next

In the next activity, you will exercise management of edge devices from RHEM, by changing and updating their operating system images and system configurations.