<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Manage Edge Devices with Red Hat Edge Manager :: Deploying Red Hat Edge Manager and Managing Edge Devices</title>
    <link rel="prev" href="index.html">
    <link rel="next" href="s2-manage-lab.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">Deploying Red Hat Edge Manager and Managing Edge Devices</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/rhde-rhem-devices/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="rhde-rhem-devices" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Deploying Red Hat Edge Manager and Managing Edge Devices</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../LABENV/index.html">Lab Environment</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch1-intro/index.html">Introduction to Red Hat Edge Manager</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s1-architecture.html">Managing Edge Devices with Red Hat Edge Manager</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/s3-classroom-lab.html">Lab: Prepare to Install Red Hat Edge Manager</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch2-deploy/index.html">Install Red Hat Edge Manager as Quadlets</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-deploy/s1-quadlets.html">Red Hat Edge Manager Services and Installation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-deploy/s2-install-lab.html">Lab: Install Red Hat Edge Manager Standalone</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch3-enroll/index.html">Add Edge Devices to Red Hat Edge Manager</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-enroll/s1-enroll.html">Enroll Edge Devices in RHEM</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-enroll/s2-enroll-lab.html">Lab: Enroll Edge Devices Using Late Binding</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Manage Edge Devices with Red Hat Edge Manager</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="s1-manage.html">Manage Edge Devices with Red Hat Edge Manager</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s2-manage-lab.html">Lab: Configure Edge Devices</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s3-update-lab.html">Lab: Update Edge Devices</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch5-decomission/index.html">Remove Edge Devices from Red Hat Edge Manager</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch5-decomission/s1-delete.html">Decommission and Delete Edge Devices with RHEM</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch5-decomission/s2-delete-lab.html">Lab: Decommission and Delete Edge Devices</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Deploying Red Hat Edge Manager and Managing Edge Devices</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Deploying Red Hat Edge Manager and Managing Edge Devices</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../samples/1/index.html">samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../samples/1/index.html">1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Deploying Red Hat Edge Manager and Managing Edge Devices</a></li>
    <li><a href="index.html">Manage Edge Devices with Red Hat Edge Manager</a></li>
    <li><a href="s1-manage.html">Manage Edge Devices with Red Hat Edge Manager</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Manage Edge Devices with Red Hat Edge Manager</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Estimated reading time: <strong>14 minutes</strong>.</em></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Objective</dt>
<dd>
<p>Configure and update managed devices using RHEM.</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Work in progress
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As we already learned, Red Hat Edge Manager (RHEM) manages three aspects of a device configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Its operating system image, as a bootc container image.</p>
</li>
<li>
<p>Operating system and application configuration files, in the <code>/etc</code> directory and other locations.</p>
</li>
<li>
<p>Workloads running as containerized applications.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this course, we focus on the first two, and we teach about managing workloads or applications with RHEM in the next course.</p>
</div>
<div class="paragraph">
<p>Before presenting RHEM device templates, let&#8217;s discuss about when it is appropriate to use RHEM to configure a device.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operating_system_configuration_at_image_build_time_day_1_and_day2"><a class="anchor" href="#_operating_system_configuration_at_image_build_time_day_1_and_day2"></a>Operating system configuration at image build time, day-1, and day2.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With image mode for RHEL, it is expected that most configurations configurations are set by a bootc container image, which would be configurations set at day-0, before provisioning a system, during image build time.
These configurations will be the same for all devices using the image.</p>
</div>
<div class="paragraph">
<p>Having configurations applied to a system image, so they are applied together with installing the operating system, instead of applied only after installing the operating system, ensures devices have a know starting state and reduces the risk of accidental drift.</p>
</div>
<div class="paragraph">
<p>While it is possible to override configurations set by a bootc container image, because the <code>/etc</code> and <code>/var</code> directories are read-write, these changes should be kept to a minimum and done only on purpose.
Modern Linux applications and services are expected to take their primary configurations from the <code>/usr/lib</code> directory, which is read-only on image mode systems, and use drop directories such as <code>/etc/something.d</code> for configuration snippets that add to or override their primary configurations.</p>
</div>
<div class="paragraph">
<p>There is always some configuration settings that must vary between different devices, or between different edge sites, and writable configuation files in the <code>/etc</code> directory should be reserved such exceptions.</p>
</div>
<div class="paragraph">
<p>There is also the matter of secrets management: it is considered a very bad security practice to embed authentication credentials such as passwords, tokens, and certificates in system images.
For example, you there should not exist any predefined user with a well-known password which could be used to access production systems, including edge devices.</p>
</div>
<div class="paragraph">
<p>Per-device and per-site configurations, and also secrets, can be applied to devices at day-1, that is, at device provisioning time (or installation time), or at day-2, which really means as a regular day-to-day management operation.</p>
</div>
<div class="paragraph">
<p>Most operating system installation and provisioning methods offer some way of adding configuration files and running configuration scripts.
The RHEL installer, called Anaconda, provides the <strong>kickstart</strong> feature, which can set all settings the installer would otherwize prompt for during an interactive installation, and also run arbitrary scripts.
It is a common practice to embed custom kickstart files in RHEL installation media, or in network boot servers, with both package and image modes.</p>
</div>
<div class="paragraph">
<p>Most hypervisors and cloud provides nowadays support the <strong>cloud-init</strong> configuration mechanism, which has similar capacities to kickstart, but with its own syntax.</p>
</div>
<div class="paragraph">
<p>By using kickstart or cloud-init scripts, you can perform bootstrapping configurations such as setting a SSH key to access the newly provisioned machines.
Having initial users and access credentials set this way makes them easier and safer to change at day-2, because they are not set by read-only files in the system image, and avoids the risk of reverting to whatever was set by the image.
But it also can be considered a risk of leak, when they are stored in installation media.</p>
</div>
<div class="paragraph">
<p>Per-device and per-site configurations, if they are expected to be set only once, at provisioning time, and never (or rarely) changed on day-2, are good candidates for kickstart and cloud-init.</p>
</div>
<div class="paragraph">
<p>Anything that you are expected to change regularly, after provisioning a device, is a good candidate for traditional operating system management tools, such as Red Hat Ansible Automation Platform, and also for edge management tools, such as RHEM.</p>
</div>
<div class="paragraph">
<p>Some organizations prefer to use day-2 tools to perform first-time configuration of new devices, that is to perform day-1 configuration on those devices.
Such organizations could provision devices using a very generic image, use day-1 just to set credentials for a management tool, and them let the management tool perform the remaining day-1 configurations.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_oboarding_devices"><a class="anchor" href="#_oboarding_devices"></a>Oboarding devices</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By the previous discussion, you know that RHEM adds configurations over whatever was already set by a bootc container image and by a provisioning mechanism, such as kickstart.
RHEM is not supposed to take over and control all configurations of a device.
You can still perform ad-hoc, manual configuration of anything that is not managed by RHEM.
And you can configure some settings using a different day-2 configuration tool, such as Ansible.</p>
</div>
<div class="paragraph">
<p>Of course, having a device configured by multiple different tools can be a challenge to manage, but you may find a scenario where it is easier, or more secure, doing it with a different tool, or using RHEM as one of the tools in a larger workflow.</p>
</div>
<div class="paragraph">
<p>For example, by onboarding an edge device most organizations mean more than just performing its first-time (day-1) configuration.
If your devices run applications which require access to other devices, cloud resources, or corporate systems, they need access credentials to all that.
Providing the required credentials securely is not a trivial task and there are specialized tools for secrets management, for example Hashicorp Vault.
You could configure everything except secrets using RHEM, and let Vault configure secrets for the device.</p>
</div>
<div class="paragraph">
<p>As another example, if your organization sets network access from devices based on their MAC address, you may need to configure networking gear as part of your device onboarding process, to set the MAC address to the desired fixed IP address, and to set the ethernet port of the device to the desired VLAN.</p>
</div>
<div class="paragraph">
<p>If you must implement a more sophisticated onboarding workflow, you may need a tool capable of orchestrating RHEM together with other management tools.
Red Hat Ansible Automation Platform is great for such tasks.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_drift_detection_and_reconcilliation"><a class="anchor" href="#_drift_detection_and_reconcilliation"></a>Drift detection and reconcilliation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So RHEM can manage operating and application configuration files, but does not need to manage all of them in any given device.
If a file is not set by RHEM configurations in a device or fleet template, they can be set by any other means.</p>
</div>
<div class="paragraph">
<p>You cannot use RHEM to forcibly lock down all configuration files in a device and prevent users or tools to perform unintended changes to those files.
But, if a file is set by RHEM configurations, RHEM will detect changes to it (configuration drift) and fix it, reverting the file to whatever contents are set by RHEM.</p>
</div>
<div class="paragraph">
<p>While it is not practical to add too many configuration files to a device template "just in case", because such configurations would be huge (just check how many files exist in the <code>/etc</code> directory of any Linux system!), RHEM provides you with a reliable recovery path from unintended changes: reinstall the device, as if were is a newly provisioned device, and let RHEM apply the expected configurations to it.
This way, you can restore any device to a known good configuration state, considering all of day-0, day-1, and day-2.</p>
</div>
<div class="paragraph">
<p>Now that you have some ideas about what to configure and when to configure something in a device using RHEM, let&#8217;s focus on the mechanics of RHEM configurations.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rhem_configuration_types"><a class="anchor" href="#_rhem_configuration_types"></a>RHEM configuration types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If a managed device is not a member of a fleet, its device API resource may contain a list of configuration items, a list of applications, and a reference to an operating system image.</p>
</div>
<div class="paragraph">
<p>Each configuration item has a name, which is supposedly a descriptive name, and a type, which specifies the configuration provider responsible for retrieving the contents of the configuration files.</p>
</div>
<div class="paragraph">
<p>With RHEM on RHEL, you would normally use these three configuration providers:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">inline</dt>
<dd>
<p>Inline configurations are stored in the device API resource itself, using the ignition format.
If these configuration files are text files, they are just YAML multiline string values.</p>
</dd>
<dt class="hdlist1">HTTP</dt>
<dd>
<p>Configurations are retrieved from a web server or anything that can respond to HTTP requests, like an S3-compatible object storage.
This alternative is commonly used to simplify integration between management tools, for example when RHEM runs integrated with Red Hat Advanced Cluster Manager, so the other management tool provides configuration files for devices managed by RHEM.</p>
</dd>
<dt class="hdlist1">Git</dt>
<dd>
<p>Configurations are retrieved from a git repository.
This enables RHEM to work as GitOps for the operating system.
It also enables easy testing and troubleshooting of configurations, because you do not need to extract and embed configuration files in a RHEM API resource: the configuration files are just regular files in a Git tree.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Notice that a single device can contain multiple configuration items, using different providers, or even using the same provider.
And each configuration item can contain multiple configuration files.
This enables logical grouping of configuration files by purpose, and enables a degree of separation of concerns.</p>
</div>
<div class="paragraph">
<p>For example, a RHEM administrator may opt for configuring some files as inline configurations, and keep control over them, while configuring other files from a Git repository, and delegate those files to non-RHEM administrators with access to that repository.</p>
</div>
<div class="paragraph">
<p>Managed devices never connect directly to external configuration providers.
For example, managed devices do not connect directly to Git servers, so they do not require access credentials to a Git repository.
The RHEM server connects to configuration provides and grab all required files, and a RHEM agent downloads all of them from its RHEM server.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In this course, we focus on the inline configuration provider, so we can learn the basics of RHEM.
In the next course we focus on the Git configuration provider, and use fleets to demonstrate an effective GitOps workflow.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operating_system_image_changes"><a class="anchor" href="#_operating_system_image_changes"></a>Operating system image changes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There is not a lot to say about managing operating system images with RHEM: a device API resource contains the name of a bootc container image.
If that field changes, the RHEM agent performs a <code>bootc switch</code> operation and reboots the device.</p>
</div>
<div class="paragraph">
<p>The new system image does not need to be related, in any way, to the previous system image.
It could provide a different RHEL release, a different set of system services, and come from a different container registry.
RHEM and bootc do not care: it&#8217;s just another system image.</p>
</div>
<div class="paragraph">
<p>That enables you to implement effective repurposing workflows, switching a device to a diferent system image, with different configurations, and running different applications.</p>
</div>
<div class="paragraph">
<p>During initial device enrollment, the operating system image field is left empty: RHEM does not record the image which the device was booted (or provisioned) with.
The system image is considered not managed by RHEM, and changeable manually by using the <code>bootc</code> command on the device, until a RHEM user explicit sets the value of the operating system image in the device template.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_updating_managed_devices"><a class="anchor" href="#_updating_managed_devices"></a>Updating managed devices</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Updating a device with RHEM may not mean what you think an update is.
Most IT professionals intuitively think about device updates as operating system updates, or patching.</p>
</div>
<div class="paragraph">
<p>To RHEM, any change to a device template&#8201;&#8212;&#8201;including a change of configurations or applications&#8201;&#8212;&#8201;is an update.
It does not need to be an update of the operating system, that is, it does not meed to make a manage device switch to an updated operating system image.</p>
</div>
<div class="paragraph">
<p>RHEM treats all of the device template as a unit, during a device reconcilliation, so if you change all three aspects of a device template, at the same time, RHEM applies all changes to configurations, system image, and applications, at one.
If any of them fails, for whatever reason, the entire update operation, or reconcilliation, failed and the device status is set to <code>Out-of-Date</code>.</p>
</div>
<div class="paragraph">
<p>If you check the device status details, you can get information about what the device failed to update, and why.
For example, a device may fail to download a bootc container image because it lacks credentials to access a container image registry.</p>
</div>
<div class="paragraph">
<p>RHEM has no concept of retrying an update.
If there&#8217;s a failure during device reconcilliation, you must change the device template, thus forcing another update operation.
RHEM assumes that updates must work all the times, else there is an issue with the device template itself, which must be fixed.</p>
</div>
<div class="paragraph">
<p>But how RHEM prevents intermitent errors?
The RHEL agent first downloads all artifacts it needs: bootc container images, configuration files, and application containers.
Only after all of them are completely downloaded and verified, it starts applying them to the device itself.</p>
</div>
<div class="paragraph">
<p>The agent may take time to download all artifacts, especially under intermitent connections, and the device status in RHEM states what the agent is still downloading artifacts.</p>
</div>
<div class="paragraph">
<p>If an update fails because of a condition internal to the device, for example low disk space, this is still considered a device template issue: it should not force into devices more files than they fit.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_shell_sessions_on_managed_devices"><a class="anchor" href="#_shell_sessions_on_managed_devices"></a>Shell sessions on managed devices</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RHEM enables its users to get a shell on a managed devices and run commands as the root user.
It uses the network connection the agent estabilishes with the RHEM server, so a device does not need to have an addressable IP address, like you would need for SSH connections.</p>
</div>
<div class="paragraph">
<p>You even could opt to not run an SSH daemon at all on managed devices and do all remote access using RHEM.</p>
</div>
<div class="paragraph">
<p>The <code>flightctl console</code> command or the <b class="menuref">Terminal</b> tab in the <b class="menuref">Device details</b> page of the web UI provide with RHEM shell sessions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_permissions_and_roles"><a class="anchor" href="#_permissions_and_roles"></a>Permissions and roles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We already learned that you must be a RHEM administrator to approve device enrollment requests, but you do not need such privileges to manage devices.</p>
</div>
<div class="paragraph">
<p>RHEM recognizes three access roles: administrator, operator, and viewer.
Users with either the administrator or the operator role can manage devices, that is, change their device templates and start shell sessions.
Users with the viewer role, as expected, cannot make such changes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In this course we do not teach the use of organizations, which enable multi-tenancy withing a RHEL server.
RHEM users might be assigned different roles in different organizations, and this is set by group membership using the PAM issuer.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_whats_next"><a class="anchor" href="#_whats_next"></a>What&#8217;s next</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The next two activities exercise device configuration and operating system updates with RHEM, and the next chapter teaches how to exclude a device from RHEM management.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="index.html">Manage Edge Devices with Red Hat Edge Manager</a></span>
  <span class="next"><a href="s2-manage-lab.html">Lab: Configure Edge Devices</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
